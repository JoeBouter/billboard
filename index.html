<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Batch Text Image Generator - Dark</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root {
    --bg:#0f1115;
    --card:#121417;
    --muted:#9aa3b2;
    --accent:#4ea3ff;
    --accent-2:#6ad1a0;
    --token-bg:#2b6fd6;
    --token-color:#fff;
    --panel:#0b0c0e;
    --glass: rgba(255,255,255,0.03);
  }
  html,body { height:100%; margin:0; font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; background:var(--bg); color:#e6eef8; }
  .wrap { display:flex; gap:18px; padding:18px; box-sizing:border-box; height:100%; align-items:flex-start; }
  .left { width:440px; min-width:320px; max-width:480px; overflow:auto; }
  .card { background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.04); border-radius:10px; padding:12px; margin-bottom:12px; box-shadow: 0 6px 18px rgba(0,0,0,0.6); }
  h1 { font-size:18px; margin:0 0 10px 0; color:#fff; }
  label { font-size:13px; color:#cfe7ff; display:block; margin-bottom:6px; font-weight:700; }
  input[type="text"], input[type="number"], select, textarea { width:100%; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); box-sizing:border-box; font-size:13px; background:var(--panel); color:#e6eef8; }
  textarea { min-height:86px; font-family:monospace; resize:vertical; color:#e6eef8; }
  .small { font-size:12px; color:var(--muted); }
  .row { display:flex; gap:8px; align-items:center; }
  .btn { background:var(--accent); color:#08101b; border:0; padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:800; }
  .btn.secondary { background:#333a44; color:#dbe9ff; border:1px solid rgba(255,255,255,0.03); }
  .btn.ghost { background:transparent; color:var(--accent); border:1px solid rgba(255,255,255,0.04); font-weight:700; }
  .muted { color:var(--muted); font-size:12px; }
  .layers { display:flex; flex-direction:column; gap:10px; margin-top:8px; }
  .layer-row { border:1px dashed rgba(255,255,255,0.03); padding:10px; border-radius:8px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005)); }
  .layer-header { display:flex; justify-content:space-between; gap:8px; align-items:center; margin-bottom:8px; }
  .layer-title { font-weight:800; font-size:13px; color:#fff; }
  .inline { display:inline-flex; gap:6px; align-items:center; }
  .preview-area { flex:1; display:flex; flex-direction:column; gap:12px; min-width:420px; max-width:100%; }
  canvas { width:100%; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:#0f1111; max-height:72vh; object-fit:contain; }
  .controls { display:flex; gap:8px; flex-wrap:wrap; }
  .token { display:inline-block; padding:4px 10px; border-radius:8px; background:var(--token-bg); color:var(--token-color); font-weight:800; margin:0 4px; font-size:12px; vertical-align:middle; user-select:none; }
  .templateBar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .token-btn { background:#0f223b; border:1px solid rgba(78,163,255,0.18); padding:6px 8px; border-radius:8px; cursor:pointer; color:var(--accent); font-weight:800; }
  .small-input { width:86px; }
  .file-list { font-size:12px; color:var(--muted); max-height:160px; overflow:auto; padding:8px; background:transparent; border-radius:6px; border:1px dashed rgba(255,255,255,0.02); }
  .hint { font-size:12px; color:var(--muted); margin-top:6px; }
  footer { font-size:12px; color:var(--muted); padding:8px 0 20px 0; }
  .two-cols { display:grid; grid-template-columns:1fr 1fr; gap:8px; }
  .count-pill { background:rgba(255,255,255,0.03); padding:6px 8px; border-radius:999px; color:var(--muted); font-weight:700; font-size:12px; }
  .danger { background:#ff6b6b; color:#fff; }
  .switch { display:flex; gap:8px; align-items:center; }
</style>
</head>
<body>
<div class="wrap">
  <div class="left">
    <div class="card">
      <h1>Batch Text Image Generator - Dark</h1>
      <div class="small">Paste a paragraph of short questions, click "Normalize" and the app will split it into separate lines for Variable mode. Works great for "Lost? Losing hope? ..." style inputs.</div>
    </div>

    <div class="card">
      <label>Global name (for filenames)</label>
      <input id="namePrefix" placeholder="CampaignName" type="text" />
      <label style="margin-top:10px">Filename template</label>
      <div class="templateBar">
        <div style="flex:1">
          <div id="filenameTemplate" contenteditable="true" style="min-height:36px; border:1px solid rgba(255,255,255,0.04); padding:8px; border-radius:8px; background:transparent; color:#eaf4ff"></div>
        </div>
        <div style="display:flex;flex-direction:column;gap:6px">
          <button class="token-btn" data-token="name">name</button>
          <button class="token-btn" data-token="res">res</button>
        </div>
      </div>
      <div id="dynamicTokenButtons" style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap"></div>
      <div class="hint">Click token buttons to insert small boxes into your template. Tokens are replaced during export.</div>
    </div>

    <div class="card">
      <label>Canvas resolution</label>
      <div style="display:flex; gap:8px; align-items:center;">
        <input id="canvasW" class="small-input" type="number" value="2048" /> <span class="muted">px wide</span>
        <input id="canvasH" class="small-input" type="number" value="1152" /> <span class="muted">px high</span>
        <div style="flex:1"></div>
        <button id="applyRes" class="btn ghost">Apply</button>
      </div>

      <label style="margin-top:10px">Background</label>
      <div style="display:flex; gap:8px;">
        <input id="bgColor" type="color" value="#0f0f10" />
        <input id="bgImageFile" type="file" accept="image/*" />
        <button id="clearBg" class="btn secondary">Clear</button>
      </div>
      <div class="hint">Background color or image. Image will be cover-scaled to canvas.</div>
    </div>

    <div class="card">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <label>Layers</label>
        <div>
          <button id="addTextLayerBtn" class="btn ghost">Add text layer</button>
          <button id="addImageLayerBtn" class="btn ghost">Add image layer</button>
        </div>
      </div>
      <div class="layers" id="layersContainer"></div>
      <div class="hint">Paste text, Toggle "Treat as list" and Normalize pasted text for automatic splitting. Use multiple text layers for headline + URL etc.</div>
    </div>

    <div class="card">
      <label>Batch options</label>
      <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
        <select id="batchMode">
          <option value="cartesian">Full combos (cartesian)</option>
          <option value="single">Vary one layer only</option>
        </select>
        <select id="singleLayerSelect"></select>
        <div style="flex:1"></div>
        <input id="paddingPx" type="number" value="30" class="small-input" />
        <span class="muted">padding px</span>
      </div>

      <div style="display:flex; gap:8px;">
        <button id="autoMaxBtn" class="btn">Auto maximize and preview</button>
        <button id="generateAllBtn" class="btn">Generate and download all</button>
        <button id="downloadPreviewBtn" class="btn secondary">Download preview</button>
      </div>

      <div class="hint" id="comboInfo">No combos yet</div>
      <div id="progress" class="hint"></div>
    </div>

    <footer class="card">
      <div class="small">Tip: If you paste a single paragraph of short questions, click Normalize so the app splits into separate items. If it still looks wrong, paste into the layer, press Normalize, then the "Treat as list" checkbox will show the detected count.</div>
    </footer>
  </div>

  <div class="preview-area">
    <div class="card" style="display:flex; flex-direction:column; gap:8px;">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <label>Preview</label>
        <div class="controls">
          <div class="muted" id="resolutionLabel">2048 x 1152</div>
        </div>
      </div>
      <canvas id="previewCanvas" width="2048" height="1152"></canvas>
      <div style="display:flex; gap:8px; justify-content:flex-end;">
        <button id="regenBtn" class="btn ghost">Render current</button>
      </div>
    </div>

    <div class="card">
      <label>Files ready to generate</label>
      <div class="file-list" id="fileList">No files yet. Click Generate and download all to build files.</div>
    </div>
  </div>
</div>

<!-- JSZip (optional) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script>
/* Dark-mode rewrite with improved list parsing for variable mode
   - normalizes pasted paragraph into list items by punctuation or newline
   - single textarea per text layer, checkbox "Treat as list"
   - visible item count per layer
   - WYSIWYG tokens, auto-maximization, zip download
*/

/* ---------- helpers ---------- */
const $ = s => document.querySelector(s);
const uid = (p='l') => p + Math.random().toString(36).slice(2,9);
const clamp = (v,a,b) => Math.max(a, Math.min(b,v));
const readFileAsDataURL = f => new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsDataURL(f); });

/* ---------- state ---------- */
let layers = [];
let bgImageData = null, bgImageObj = null;
let canvasW = 2048, canvasH = 1152;
let paddingPx = 30;
const previewCanvas = $('#previewCanvas');
const previewCtx = previewCanvas.getContext('2d', { alpha: true });
const measureCanvas = document.createElement('canvas');
const measureCtx = measureCanvas.getContext('2d');
const zipAvailable = typeof JSZip !== 'undefined';

/* ---------- ui refs ---------- */
const layersContainer = $('#layersContainer');
const dynamicTokenButtons = $('#dynamicTokenButtons');
const filenameTemplate = $('#filenameTemplate');
const namePrefixEl = $('#namePrefix');
const canvasWEl = $('#canvasW'), canvasHEl = $('#canvasH');
const applyResBtn = $('#applyRes');
const bgColorEl = $('#bgColor'), bgImageFileEl = $('#bgImageFile'), clearBgBtn = $('#clearBg');
const addTextLayerBtn = $('#addTextLayerBtn'), addImageLayerBtn = $('#addImageLayerBtn');
const batchModeEl = $('#batchMode'), singleLayerSelect = $('#singleLayerSelect');
const paddingPxEl = $('#paddingPx');
const autoMaxBtn = $('#autoMaxBtn'), generateAllBtn = $('#generateAllBtn'), downloadPreviewBtn = $('#downloadPreviewBtn'), regenBtn = $('#regenBtn');
const fileListEl = $('#fileList'), comboInfoEl = $('#comboInfo'), progressEl = $('#progress'), resolutionLabel = $('#resolutionLabel');

/* ---------- token helpers ---------- */
function makeTokenSpan(name) {
  const span = document.createElement('span');
  span.className = 'token';
  span.dataset.token = name;
  span.contentEditable = "false";
  span.textContent = name;
  return span;
}
function insertTokenToTemplate(name) {
  const sel = window.getSelection();
  filenameTemplate.focus();
  const span = makeTokenSpan(name);
  if (!sel || sel.rangeCount === 0) {
    filenameTemplate.appendChild(span);
    filenameTemplate.appendChild(document.createTextNode(' '));
    placeCaretAfter(span);
    return;
  }
  const range = sel.getRangeAt(0);
  range.collapse(false);
  range.insertNode(span);
  range.setStartAfter(span);
  range.setEndAfter(span);
  sel.removeAllRanges();
  sel.addRange(range);
  const sp = document.createTextNode(' ');
  range.insertNode(sp);
  range.setStartAfter(sp);
  range.setEndAfter(sp);
  sel.removeAllRanges();
  sel.addRange(range);
}
function placeCaretAfter(node){
  const range = document.createRange();
  range.setStartAfter(node);
  range.collapse(true);
  const sel = window.getSelection();
  sel.removeAllRanges();
  sel.addRange(range);
}

/* ---------- parsing pasted paragraph into list items ---------- */
function parseListFromText(raw){
  if (!raw) return [];
  raw = raw.replace(/\r/g,'').trim();
  // If it already has newlines, split on them
  if (raw.includes('\n')) {
    return raw.split(/\n/).map(s=>s.trim()).filter(Boolean);
  }
  // If it contains punctuation boundaries (?.!), split on sentence ends
  const sentences = raw.split(/(?<=[\?\!\.])\s+/);
  if (sentences.length > 1) {
    return sentences.map(s => s.trim()).filter(Boolean);
  }
  // if it's a chain of question marks with space separators ("Lost? Losing hope? ...") split on "? "
  if (raw.includes('? ')) {
    const parts = raw.split(/\?\s+/).map(s=>s.trim()).filter(Boolean);
    // put question mark back
    return parts.map(p => p.endsWith('?') ? p : p + '?');
  }
  // fallback: split by " - " or " • " or " | "
  if (raw.includes(' - ') || raw.includes(' | ') || raw.includes('•')) {
    return raw.split(/ - |\s\|\s|•/).map(s=>s.trim()).filter(Boolean);
  }
  // final fallback: treat as one item
  return [raw];
}

/* ---------- layers factory ---------- */
function createTextLayerDefault(){
  return {
    id: uid('t'),
    type: 'text',
    label: 'Text',
    visible: true,
    text: 'Lost?\nLosing hope?\nLooking for peace?',
    treatAsList: true,
    items: [], // parsed items if treatAsList
    sizePct: 100,
    lineHeight: 1.05,
    fillType: 'color',
    color: '#ffffff',
    fillImageData: null,
    fillImageObj: null,
    align: 'center',
    x: 50, y: 30,
    maxWidthPct: 90
  };
}
function createImageLayerDefault(){
  return {
    id: uid('i'),
    type: 'image',
    label: 'Image',
    visible: true,
    imageData: null,
    imageObj: null,
    x: 50, y: 50,
    maxWidthPct: 80,
    maxHeightPct: 80,
    fit: 'cover'
  };
}

/* ---------- UI rendering ---------- */
function refreshDynamicTokenButtons(){
  dynamicTokenButtons.innerHTML = '';
  layers.forEach((L, idx) => {
    if (L.type === 'text') {
      const b = document.createElement('button');
      b.className = 'token-btn';
      b.textContent = 'text' + (idx+1);
      b.dataset.token = 'text' + (idx+1);
      b.title = 'Insert token for text layer ' + (idx+1);
      b.addEventListener('click', ()=> insertTokenToTemplate(b.dataset.token));
      dynamicTokenButtons.appendChild(b);
    }
  });
  const idxBtn = document.createElement('button');
  idxBtn.className = 'token-btn';
  idxBtn.textContent = 'index';
  idxBtn.addEventListener('click', ()=> insertTokenToTemplate('index'));
  dynamicTokenButtons.appendChild(idxBtn);
}

function renderLayersUI(){
  layersContainer.innerHTML = '';
  layers.forEach((L, idx) => {
    const el = document.createElement('div');
    el.className = 'layer-row';
    el.dataset.id = L.id;

    const header = document.createElement('div');
    header.className = 'layer-header';
    const title = document.createElement('div');
    title.className = 'layer-title';
    title.textContent = `${idx+1}. ${L.label || (L.type==='text' ? 'Text' : 'Image')}`;
    header.appendChild(title);

    const headerControls = document.createElement('div');
    headerControls.className = 'inline';
    const up = document.createElement('button'); up.textContent='↑'; up.className='btn ghost'; up.style.padding='4px 8px';
    const down = document.createElement('button'); down.textContent='↓'; down.className='btn ghost'; down.style.padding='4px 8px';
    const remove = document.createElement('button'); remove.textContent='Remove'; remove.className='btn ghost';
    headerControls.append(up, down, remove);
    header.appendChild(headerControls);
    el.appendChild(header);

    up.addEventListener('click', ()=> moveLayerUp(L.id));
    down.addEventListener('click', ()=> moveLayerDown(L.id));
    remove.addEventListener('click', ()=> {
      if (confirm('Remove layer?')) { removeLayer(L.id); }
    });

    // body
    const body = document.createElement('div');
    body.style.display = 'grid';
    body.style.gap = '8px';

    // visibility
    const visRow = document.createElement('div'); visRow.className='row';
    const visC = document.createElement('input'); visC.type='checkbox'; visC.checked = L.visible;
    visC.addEventListener('change', ()=> { L.visible = visC.checked; renderPreview(); });
    const visLabel = document.createElement('div'); visLabel.className='small muted'; visLabel.textContent='Visible';
    visRow.append(visC, visLabel);
    body.appendChild(visRow);

    // label
    const labelInput = document.createElement('input'); labelInput.type='text'; labelInput.value = L.label || '';
    labelInput.addEventListener('input', ()=> { L.label = labelInput.value; renderLayersUI(); });
    body.appendChild(labelInput);

    if (L.type === 'text') {
      // textarea (single control)
      const ta = document.createElement('textarea'); ta.value = L.text || '';
      ta.placeholder = 'Paste text here. Use Normalize for one-per-line lists.';
      ta.addEventListener('input', ()=> { L.text = ta.value; if (L.treatAsList) { L.items = parseListFromText(L.text); } updateLayerCountUI(L.id); renderPreview(); });
      // on paste: try auto-normalize if it looks like a single paragraph with punctuation
      ta.addEventListener('paste', (ev)=> {
        setTimeout(()=> {
          L.text = ta.value;
          // if no newline and contains '? ' or '. ' or '! ' then auto-parse
          if (!L.text.includes('\n') && /[?!\.]\s+/.test(L.text)) {
            L.items = parseListFromText(L.text);
            L.treatAsList = true;
          } else {
            L.items = parseListFromText(L.text);
          }
          updateLayerCountUI(L.id);
          renderPreview();
        }, 50);
      });
      body.appendChild(ta);

      // controls: treat as list, normalize, detected count
      const controlsRow = document.createElement('div'); controlsRow.style.display='flex'; controlsRow.style.gap='8px'; controlsRow.style.alignItems='center';
      const listCheck = document.createElement('input'); listCheck.type = 'checkbox'; listCheck.checked = L.treatAsList;
      const listLabel = document.createElement('div'); listLabel.className='small'; listLabel.textContent = 'Treat as list (one item per line)';
      listCheck.addEventListener('change', ()=> {
        L.treatAsList = listCheck.checked;
        if (L.treatAsList) L.items = parseListFromText(ta.value || '');
        else L.items = [];
        updateLayerCountUI(L.id);
        renderPreview();
      });
      const normalizeBtn = document.createElement('button'); normalizeBtn.className='btn secondary'; normalizeBtn.textContent='Normalize pasted text';
      normalizeBtn.addEventListener('click', ()=> {
        const parsed = parseListFromText(ta.value || '');
        if (parsed.length > 1) {
          ta.value = parsed.join('\\n');
          L.text = ta.value;
          L.treatAsList = true;
          L.items = parsed;
          listCheck.checked = true;
          updateLayerCountUI(L.id);
          renderPreview();
          alert('Normalized into ' + parsed.length + ' lines.');
        } else {
          alert('Could not split into multiple items. Try editing or ensure there are sentence-end punctuation marks.');
        }
      });
      const countPill = document.createElement('div'); countPill.className = 'count-pill'; countPill.id = 'count-' + L.id; countPill.textContent = 'Items: 0';
      controlsRow.append(listCheck, listLabel, normalizeBtn, countPill);
      body.appendChild(controlsRow);

      // sizes and style
      const twoCols = document.createElement('div'); twoCols.className='two-cols';
      const sizeInput = document.createElement('input'); sizeInput.type='number'; sizeInput.value = L.sizePct || 100; sizeInput.addEventListener('input', ()=> { L.sizePct = Number(sizeInput.value)||100; renderPreview(); });
      const lhInput = document.createElement('input'); lhInput.type='number'; lhInput.step='0.05'; lhInput.value = L.lineHeight || 1.05; lhInput.addEventListener('input', ()=> { L.lineHeight = Number(lhInput.value)||1.05; renderPreview(); });
      const sizeLabel = document.createElement('label'); sizeLabel.textContent='Relative size (%)';
      const lhLabel = document.createElement('label'); lhLabel.textContent='Line height x';
      twoCols.append(sizeLabel, lhLabel, sizeInput, lhInput);
      body.appendChild(twoCols);

      // fill color / image
      const fillRow = document.createElement('div'); fillRow.style.display='flex'; fillRow.style.gap='8px'; fillRow.style.alignItems='center';
      const fillSelect = document.createElement('select'); fillSelect.innerHTML = '<option value="color">Color</option><option value="image">Image fill</option>'; fillSelect.value = L.fillType || 'color';
      const colorInput = document.createElement('input'); colorInput.type='color'; colorInput.value = L.color || '#ffffff'; colorInput.addEventListener('input', ()=> { L.color = colorInput.value; renderPreview(); });
      const imgFile = document.createElement('input'); imgFile.type='file'; imgFile.accept='image/*';
      imgFile.addEventListener('change', async (e)=> { const f = e.target.files[0]; if (!f) return; L.fillImageData = await readFileAsDataURL(f); L.fillImageObj = await dataURLToImage(L.fillImageData); renderPreview(); });
      fillSelect.addEventListener('change', ()=> { L.fillType = fillSelect.value; colorInput.style.display = L.fillType==='color' ? 'inline-block' : 'none'; imgFile.style.display = L.fillType==='image' ? 'inline-block' : 'none'; renderPreview(); });
      if (L.fillType !== 'color') colorInput.style.display='none';
      if (L.fillType !== 'image') imgFile.style.display='none';
      fillRow.append(fillSelect, colorInput, imgFile);
      body.appendChild(fillRow);

      // position and max width
      const posRow = document.createElement('div'); posRow.style.display='flex'; posRow.style.gap='8px'; posRow.style.alignItems='center';
      const alignSel = document.createElement('select'); alignSel.innerHTML = '<option value="center">center</option><option value="top">top</option><option value="bottom">bottom</option><option value="left">left</option><option value="right">right</option>'; alignSel.value = L.align || 'center'; alignSel.addEventListener('change', ()=> { L.align = alignSel.value; renderPreview(); });
      const xPos = document.createElement('input'); xPos.type='number'; xPos.value = L.x || 50; xPos.min=0; xPos.max=100; xPos.className='small-input'; xPos.addEventListener('input', ()=> { L.x = clamp(Number(xPos.value)||50,0,100); renderPreview(); });
      const yPos = document.createElement('input'); yPos.type='number'; yPos.value = L.y || 50; yPos.min=0; yPos.max=100; yPos.className='small-input'; yPos.addEventListener('input', ()=> { L.y = clamp(Number(yPos.value)||50,0,100); renderPreview(); });
      const maxW = document.createElement('input'); maxW.type='number'; maxW.value = L.maxWidthPct || 90; maxW.min=1; maxW.max=100; maxW.className='small-input'; maxW.addEventListener('input', ()=> { L.maxWidthPct = clamp(Number(maxW.value)||90,1,100); renderPreview(); });
      posRow.append(alignSel, xPos, yPos, maxW);
      body.append(posRow);
    } else {
      // image layer
      const fileRow = document.createElement('div'); fileRow.style.display='flex'; fileRow.style.gap='8px'; fileRow.style.alignItems='center';
      const fileInput = document.createElement('input'); fileInput.type='file'; fileInput.accept='image/*';
      const fitSel = document.createElement('select'); fitSel.innerHTML = '<option value="cover">cover</option><option value="contain">contain</option>'; fitSel.value = L.fit;
      const maxW = document.createElement('input'); maxW.type='number'; maxW.value = L.maxWidthPct || 80; maxW.min=1; maxW.max=100; maxW.className='small-input';
      const maxH = document.createElement('input'); maxH.type='number'; maxH.value = L.maxHeightPct || 80; maxH.min=1; maxH.max=100; maxH.className='small-input';
      fileInput.addEventListener('change', async (e)=> { const f = e.target.files[0]; if(!f) return; L.imageData = await readFileAsDataURL(f); L.imageObj = await dataURLToImage(L.imageData); renderPreview(); });
      fitSel.addEventListener('change', ()=> { L.fit = fitSel.value; renderPreview(); });
      maxW.addEventListener('input', ()=> { L.maxWidthPct = clamp(Number(maxW.value)||80,1,100); renderPreview(); });
      maxH.addEventListener('input', ()=> { L.maxHeightPct = clamp(Number(maxH.value)||80,1,100); renderPreview(); });
      fileRow.append(fileInput, fitSel, maxW, maxH);
      body.appendChild(fileRow);

      const posRow = document.createElement('div'); posRow.style.display='flex'; posRow.style.gap='6px';
      const xPos = document.createElement('input'); xPos.type='number'; xPos.value = L.x || 50; xPos.min=0; xPos.max=100; xPos.className='small-input'; xPos.addEventListener('input', ()=> { L.x = clamp(Number(xPos.value)||50,0,100); renderPreview(); });
      const yPos = document.createElement('input'); yPos.type='number'; yPos.value = L.y || 50; yPos.min=0; yPos.max=100; yPos.className='small-input'; yPos.addEventListener('input', ()=> { L.y = clamp(Number(yPos.value)||50,0,100); renderPreview(); });
      posRow.append(xPos, yPos);
      body.append(posRow);
    }

    el.appendChild(body);
    layersContainer.appendChild(el);
  });

  // update singleLayerSelect
  singleLayerSelect.innerHTML = '';
  layers.forEach((L,i) => {
    if (L.type === 'text') {
      const o = document.createElement('option'); o.value = L.id; o.textContent = `${i+1}. ${L.label || 'Text'}`; singleLayerSelect.appendChild(o);
    }
  });
  refreshDynamicTokenButtons();
  renderPreview();
}

/* ---------- layer operations ---------- */
function moveLayerUp(id){
  const i = layers.findIndex(l=>l.id===id);
  if (i>0){ const a = layers.splice(i,1)[0]; layers.splice(i-1,0,a); renderLayersUI(); }
}
function moveLayerDown(id){
  const i = layers.findIndex(l=>l.id===id);
  if (i>=0 && i < layers.length-1){ const a = layers.splice(i,1)[0]; layers.splice(i+1,0,a); renderLayersUI(); }
}
function removeLayer(id){
  layers = layers.filter(l=>l.id!==id); renderLayersUI();
}
function addTextLayer(){ layers.push(createTextLayerDefault()); renderLayersUI(); }
function addImageLayer(){ layers.push(createImageLayerDefault()); renderLayersUI(); }

/* ---------- measurement & wrapping ---------- */
function setMeasureFont(sz, family='sans-serif'){ measureCtx.font = Math.round(sz)+'px '+family; measureCtx.textBaseline='middle'; }
function wrapText(ctx, text, maxW){
  const words = (text||'').split(/\s+/);
  const lines = [];
  let line = '';
  for (const w of words){
    const test = line ? (line + ' ' + w) : w;
    if (ctx.measureText(test).width <= maxW || !line) line = test;
    else { lines.push(line); line = w; }
  }
  if (line) lines.push(line);
  return lines;
}
function measureBlock(text, fontSize, lineHeight, maxWidthPx){
  setMeasureFont(fontSize);
  const paragraphs = (text||'').split(/\n/);
  let lines = [];
  for (const p of paragraphs){
    const wrapped = wrapText(measureCtx, p||'', maxWidthPx);
    if (wrapped.length === 0) wrapped.push('');
    wrapped.forEach(l => lines.push(l));
  }
  const lhPx = fontSize * lineHeight;
  let width = 0;
  for (const l of lines) width = Math.max(width, measureCtx.measureText(l).width);
  const height = lines.length * lhPx;
  return { width, height, lines, lineHeight: lhPx, lineCount: lines.length };
}

/* ---------- auto-maximization ---------- */
async function autoMaximizeAndPreview(){
  paddingPx = Number(paddingPxEl.value) || 30;
  let lo = 6, hi = Math.max(canvasW, canvasH) * 2;
  let best = lo;
  for (let iter=0; iter<24; iter++){
    const mid = Math.floor((lo + hi)/2);
    if (await baseSizeFits(mid)){ best = mid; lo = mid + 1; } else { hi = mid - 1; }
  }
  window.__chosenBaseSize = best;
  progressEl.textContent = 'Chosen base size: ' + best + ' px';
  renderPreview();
}
async function baseSizeFits(baseSize){
  for (const L of layers){
    if (!L.visible || L.type !== 'text') continue;
    // choose longest sample - if treatAsList, check longest item
    let samples = [L.text || ''];
    if (L.treatAsList) {
      L.items = parseListFromText(L.text || '');
      samples = (L.items.length > 0 ? L.items.slice() : ['']);
    }
    let longest = samples.reduce((a,b)=> a.length>b.length ? a : b, samples[0] || '');
    const fontSize = baseSize * (Number(L.sizePct)||100)/100;
    const maxWidthPx = canvasW * ((Number(L.maxWidthPct)||90)/100);
    const measured = measureBlock(longest, fontSize, Number(L.lineHeight)||1.05, maxWidthPx);
    const anchorX = canvasW * (Number(L.x)||50)/100;
    const anchorY = canvasH * (Number(L.y)||50)/100;
    const align = L.align || 'center';
    let left, top;
    if (align === 'center'){ left = anchorX - measured.width/2; top = anchorY - measured.height/2; }
    else if (align === 'top'){ left = anchorX - measured.width/2; top = anchorY; }
    else if (align === 'bottom'){ left = anchorX - measured.width/2; top = anchorY - measured.height; }
    else if (align === 'left'){ left = anchorX; top = anchorY - measured.height/2; }
    else { left = anchorX - measured.width; top = anchorY - measured.height/2; }
    if (left < paddingPx - 0.5) return false;
    if (top < paddingPx - 0.5) return false;
    if (left + measured.width > canvasW - paddingPx + 0.5) return false;
    if (top + measured.height > canvasH - paddingPx + 0.5) return false;
  }
  return true;
}

/* ---------- rendering ---------- */
function clearCanvas(ctx){ ctx.clearRect(0,0,canvasW,canvasH); }
async function renderPreview(specificMap=null){
  previewCanvas.width = canvasW; previewCanvas.height = canvasH;
  resolutionLabel.textContent = canvasW + ' x ' + canvasH;
  clearCanvas(previewCtx);
  // background
  previewCtx.fillStyle = bgColorEl.value || '#0f0f10';
  previewCtx.fillRect(0,0,canvasW,canvasH);
  if (bgImageObj) drawCoverImage(previewCtx, bgImageObj, 0,0,canvasW,canvasH);
  const baseSize = window.__chosenBaseSize || Math.round(Math.min(canvasW, canvasH)/8);
  for (const L of layers){
    if (!L.visible) continue;
    if (L.type === 'image'){
      if (!L.imageObj) continue;
      const maxWpx = canvasW * (L.maxWidthPct / 100);
      const maxHpx = canvasH * (L.maxHeightPct / 100);
      let dw = L.imageObj.width, dh = L.imageObj.height;
      if (L.fit === 'cover'){ const scale = Math.max(maxWpx/dw, maxHpx/dh); dw *= scale; dh *= scale; }
      else { const scale = Math.min(maxWpx/dw, maxHpx/dh); dw *= scale; dh *= scale; }
      const cx = canvasW * (L.x/100), cy = canvasH * (L.y/100), dx = Math.round(cx - dw/2), dy = Math.round(cy - dh/2);
      previewCtx.drawImage(L.imageObj, dx, dy, dw, dh);
    } else if (L.type === 'text'){
      let text = '';
      if (specificMap && specificMap[L.id] !== undefined) text = specificMap[L.id];
      else if (L.treatAsList && L.items && L.items.length > 0) text = L.items[0];
      else text = L.text || '';
      const fontSize = baseSize * (Number(L.sizePct)||100)/100;
      const lineHeight = Number(L.lineHeight) || 1.05;
      const maxWidthPx = canvasW * ((Number(L.maxWidthPct)||90)/100);
      const block = measureBlock(text, fontSize, lineHeight, maxWidthPx);
      const align = L.align || 'center';
      let textAlign = 'center', baseline = 'middle';
      if (align === 'center'){ textAlign='center'; baseline='middle'; }
      else if (align === 'top'){ textAlign='center'; baseline='top'; }
      else if (align === 'bottom'){ textAlign='center'; baseline='bottom'; }
      else if (align === 'left'){ textAlign='left'; baseline='middle'; }
      else if (align === 'right'){ textAlign='right'; baseline='middle'; }
      previewCtx.save();
      previewCtx.font = `${Math.round(fontSize)}px sans-serif`;
      previewCtx.textAlign = textAlign; previewCtx.textBaseline = baseline;
      const anchorX = canvasW * (Number(L.x)||50)/100; const anchorY = canvasH * (Number(L.y)||50)/100;
      let startY;
      if (baseline === 'middle') startY = anchorY - block.height/2 + (block.lineHeight/2);
      else if (baseline === 'top') startY = anchorY;
      else startY = anchorY - block.height + (block.lineHeight/2);
      if (L.fillType === 'color' || !L.fillImageObj) {
        previewCtx.fillStyle = L.color || '#fff';
        for (let i=0;i<block.lines.length;i++){ const y = startY + i * block.lineHeight; previewCtx.fillText(block.lines[i], anchorX, y); }
      } else {
        // draw image fill masked by text
        const tmp = document.createElement('canvas'); tmp.width = canvasW; tmp.height = canvasH;
        const tctx = tmp.getContext('2d');
        const img = L.fillImageObj;
        if (img) {
          let left;
          if (textAlign === 'center') left = anchorX - block.width/2;
          else if (textAlign === 'left') left = anchorX;
          else left = anchorX - block.width;
          const top = startY - (block.lineHeight/2);
          let scale = Math.max(block.width / img.width, block.height / img.height);
          const dw = img.width * scale, dh = img.height * scale;
          const dx = left + (block.width - dw)/2, dy = top + (block.height - dh)/2;
          tctx.drawImage(img, dx, dy, dw, dh);
        }
        tctx.globalCompositeOperation = 'destination-in';
        tctx.fillStyle = 'black';
        tctx.font = previewCtx.font;
        tctx.textAlign = previewCtx.textAlign;
        tctx.textBaseline = previewCtx.textBaseline;
        for (let i=0;i<block.lines.length;i++){ const y = startY + i * block.lineHeight; tctx.fillText(block.lines[i], anchorX, y); }
        previewCtx.drawImage(tmp, 0, 0);
      }
      previewCtx.restore();
    }
  }
}

/* ---------- draw helpers ---------- */
function drawCoverImage(ctx, img, x,y,w,h){
  const iw = img.width, ih = img.height;
  const scale = Math.max(w/iw, h/ih);
  const dw = iw * scale, dh = ih * scale;
  const dx = x + (w - dw)/2, dy = y + (h - dh)/2;
  ctx.drawImage(img, dx, dy, dw, dh);
}
function dataURLToImage(dataURL){
  return new Promise((res,rej)=>{ const img = new Image(); img.crossOrigin='anonymous'; img.onload = ()=> res(img); img.onerror = rej; img.src = dataURL; });
}

/* ---------- combos generation ---------- */
function gatherVarLayers(){
  // return array of {layer, values}
  const vars = [];
  layers.forEach(L => {
    if (L.type === 'text' && L.treatAsList) {
      L.items = parseListFromText(L.text || '');
      if (L.items.length > 0) vars.push({layer: L, values: L.items.slice()});
    }
  });
  return vars;
}
function countCombos(){
  const vars = gatherVarLayers();
  if (vars.length === 0) return 0;
  if (batchModeEl.value === 'single') {
    const selId = singleLayerSelect.value;
    const v = vars.find(x => x.layer.id === selId);
    return v ? v.values.length : 0;
  }
  return vars.reduce((acc,v) => acc * Math.max(1, v.values.length), 1);
}
function buildCombos(){
  const vars = gatherVarLayers();
  if (vars.length === 0) return [];
  if (batchModeEl.value === 'single') {
    const selId = singleLayerSelect.value;
    const chosen = vars.find(v => v.layer.id === selId);
    if (!chosen) return [];
    return chosen.values.map(val => {
      const map = {};
      layers.forEach(L => {
        if (L.type !== 'text') return;
        if (L.id === chosen.layer.id) map[L.id] = val;
        else map[L.id] = L.treatAsList ? (L.items[0] || '') : (L.text || '');
      });
      return map;
    });
  }
  // full cartesian
  const lists = vars.map(v => ({id: v.layer.id, values: v.values.length ? v.values : ['']}));
  const results = [];
  function recurse(i, acc){
    if (i === lists.length) { results.push(Object.assign({}, acc)); return; }
    const cur = lists[i];
    for (const val of cur.values) { acc[cur.id] = val; recurse(i+1, acc); }
  }
  recurse(0, {});
  // attach other fixed layers
  return results.map(map => {
    const full = {};
    layers.forEach(L => { if (L.type === 'text') full[L.id] = map[L.id] !== undefined ? map[L.id] : (L.treatAsList ? (L.items[0]||'') : (L.text || '')); });
    return full;
  });
}

/* ---------- filename rendering ---------- */
function renderFileNameFromTemplate(dataMap, indexFallback){
  const nodes = Array.from(filenameTemplate.childNodes);
  let out = '';
  for (const n of nodes){
    if (n.nodeType === Node.TEXT_NODE) out += n.textContent;
    else if (n.nodeType === Node.ELEMENT_NODE && n.classList.contains('token')){
      const tk = n.dataset.token;
      if (tk === 'res') out += (canvasW + 'x' + canvasH);
      else if (tk === 'name') out += (namePrefixEl.value || '');
      else if (tk === 'index') out += (indexFallback !== undefined ? String(indexFallback) : '');
      else if (tk.startsWith('text')){
        const idx = Number(tk.replace('text',''));
        if (!isNaN(idx) && idx >= 1){
          const textLayers = layers.filter(l => l.type === 'text');
          const L = textLayers[idx-1];
          if (L) {
            const val = dataMap && dataMap[L.id] !== undefined ? dataMap[L.id] : (L.treatAsList ? (L.items && L.items[0] || '') : (L.text || ''));
            out += (val || '');
          }
        }
      } else out += n.textContent;
    }
  }
  out = out.trim();
  out = out.replace(/[<>:"/\\|?*]+/g, '_');
  if (!out) out = 'output';
  return out;
}

/* ---------- generate + download ---------- */
async function ensureImgsLoaded(){
  const p = [];
  if (bgImageData && !bgImageObj) p.push((async ()=> { bgImageObj = await dataURLToImage(bgImageData); })());
  layers.forEach(L => {
    if (L.type === 'text' && L.fillType === 'image' && L.fillImageData && !L.fillImageObj) p.push((async ()=> { L.fillImageObj = await dataURLToImage(L.fillImageData); })());
    if (L.type === 'image' && L.imageData && !L.imageObj) p.push((async ()=> { L.imageObj = await dataURLToImage(L.imageData); })());
  });
  await Promise.all(p);
}
async function drawLayersToContext(ctx, dataMap){
  const baseSize = window.__chosenBaseSize || Math.round(Math.min(canvasW, canvasH)/8);
  for (const L of layers){
    if (!L.visible) continue;
    if (L.type === 'image'){
      if (!L.imageObj) continue;
      const maxWpx = canvasW * (L.maxWidthPct/100), maxHpx = canvasH * (L.maxHeightPct/100);
      let dw = L.imageObj.width, dh = L.imageObj.height;
      if (L.fit === 'cover'){ const scale = Math.max(maxWpx/dw, maxHpx/dh); dw *= scale; dh *= scale; }
      else { const scale = Math.min(maxWpx/dw, maxHpx/dh); dw *= scale; dh *= scale; }
      const cx = canvasW*(L.x/100), cy = canvasH*(L.y/100), dx = Math.round(cx - dw/2), dy = Math.round(cy - dh/2);
      ctx.drawImage(L.imageObj, dx, dy, dw, dh);
    } else if (L.type === 'text'){
      const text = dataMap && dataMap[L.id] !== undefined ? dataMap[L.id] : (L.treatAsList ? (L.items && L.items[0] || '') : (L.text || ''));
      const fontSize = baseSize * (Number(L.sizePct)||100)/100;
      const lineHeight = Number(L.lineHeight) || 1.05;
      const maxWidthPx = canvasW * ((Number(L.maxWidthPct)||90)/100);
      const block = measureBlock(text, fontSize, lineHeight, maxWidthPx);
      const align = L.align || 'center';
      let textAlign = 'center', baseline = 'middle';
      if (align === 'center'){ textAlign='center'; baseline='middle'; }
      else if (align === 'top'){ textAlign='center'; baseline='top'; }
      else if (align === 'bottom'){ textAlign='center'; baseline='bottom'; }
      else if (align === 'left'){ textAlign='left'; baseline='middle'; }
      else if (align === 'right'){ textAlign='right'; baseline='middle'; }
      ctx.save();
      ctx.font = `${Math.round(fontSize)}px sans-serif`;
      ctx.textAlign = textAlign; ctx.textBaseline = baseline;
      const anchorX = canvasW * (Number(L.x)||50)/100; const anchorY = canvasH * (Number(L.y)||50)/100;
      let startY;
      if (baseline === 'middle') startY = anchorY - block.height/2 + (block.lineHeight/2);
      else if (baseline === 'top') startY = anchorY;
      else startY = anchorY - block.height + (block.lineHeight/2);
      if (L.fillType === 'color' || !L.fillImageObj) {
        ctx.fillStyle = L.color || '#fff';
        for (let i=0;i<block.lines.length;i++){ const y = startY + i * block.lineHeight; ctx.fillText(block.lines[i], anchorX, y); }
      } else {
        // image fill masked by text
        const tmp = document.createElement('canvas'); tmp.width = canvasW; tmp.height = canvasH;
        const tctx = tmp.getContext('2d');
        const img = L.fillImageObj;
        if (img) {
          let left; if (textAlign === 'center') left = anchorX - block.width/2; else if (textAlign === 'left') left = anchorX; else left = anchorX - block.width;
          const top = startY - (block.lineHeight/2);
          let scale = Math.max(block.width / img.width, block.height / img.height);
          const dw = img.width * scale, dh = img.height * scale;
          const dx = left + (block.width - dw)/2, dy = top + (block.height - dh)/2;
          tctx.drawImage(img, dx, dy, dw, dh);
        }
        tctx.globalCompositeOperation = 'destination-in';
        tctx.fillStyle = 'black';
        tctx.font = ctx.font;
        tctx.textAlign = ctx.textAlign; tctx.textBaseline = ctx.textBaseline;
        for (let i=0;i<block.lines.length;i++){ const y = startY + i * block.lineHeight; tctx.fillText(block.lines[i], anchorX, y); }
        ctx.drawImage(tmp, 0, 0);
      }
      ctx.restore();
    }
  }
}

async function generateAndDownloadAll(){
  paddingPx = Number(paddingPxEl.value) || 30;
  const combos = buildCombos();
  if (!combos || combos.length === 0) {
    alert('No variable combos found. Make at least one text layer "Treat as list" and paste multiple items.');
    return;
  }
  const total = combos.length;
  comboInfoEl.textContent = `Preparing ${total} files`;
  if (total > 500 && !confirm('Generating ' + total + ' images may be slow and use lots of memory. Continue?')) return;
  await ensureImgsLoaded();
  const useZip = zipAvailable && total > 1;
  const zip = useZip ? new JSZip() : null;
  let count = 0;
  for (let i=0;i<combos.length;i++){
    const map = combos[i];
    const tmp = document.createElement('canvas'); tmp.width = canvasW; tmp.height = canvasH;
    const tctx = tmp.getContext('2d');
    tctx.fillStyle = bgColorEl.value || '#0f0f10'; tctx.fillRect(0,0,canvasW,canvasH);
    if (bgImageObj) drawCoverImage(tctx, bgImageObj, 0,0,canvasW,canvasH);
    await drawLayersToContext(tctx, map);
    const blob = await new Promise(res => tmp.toBlob(res, 'image/png'));
    let filename = renderFileNameFromTemplate(map, i+1);
    filename = filename + ` ${canvasW}x${canvasH}.png`;
    if (useZip) zip.file(filename, blob);
    else {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }
    count++;
    progressEl.textContent = `Generated ${count}/${total}`;
    await new Promise(r => setTimeout(r, 20));
  }
  if (useZip) {
    progressEl.textContent = 'Zipping...';
    const content = await zip.generateAsync({type:'blob'}, meta => { progressEl.textContent = `Zipping ${Math.round(meta.percent)}%`; });
    const url = URL.createObjectURL(content);
    const a = document.createElement('a'); a.href = url; a.download = (namePrefixEl.value || 'batch') + ` ${canvasW}x${canvasH}.zip`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    progressEl.textContent = 'Done.';
  } else {
    progressEl.textContent = `Finished ${count} downloads.`;
  }
}

/* ---------- event wiring ---------- */
addTextLayerBtn.addEventListener('click', ()=> addTextLayer());
addImageLayerBtn.addEventListener('click', ()=> addImageLayer());
applyResBtn.addEventListener('click', ()=> { canvasW = Math.max(16, Number(canvasWEl.value)||canvasW); canvasH = Math.max(16, Number(canvasHEl.value)||canvasH); resolutionLabel.textContent = canvasW + ' x ' + canvasH; renderPreview(); });
bgImageFileEl.addEventListener('change', async (e)=> { const f = e.target.files[0]; if (!f) return; bgImageData = await readFileAsDataURL(f); bgImageObj = await dataURLToImage(bgImageData); renderPreview(); });
clearBgBtn.addEventListener('click', ()=> { bgImageData = null; bgImageObj = null; bgImageFileEl.value = ''; renderPreview(); });
document.querySelectorAll('.token-btn').forEach(b => b.addEventListener('click', ()=> insertTokenToTemplate(b.dataset.token)));
regenerateDynamicTokenButtons = refreshDynamicTokenButtons;
autoMaxBtn.addEventListener('click', async ()=> { progressEl.textContent = 'Computing...'; await autoMaximizeAndPreview(); });
regenBtn.addEventListener('click', ()=> renderPreview());
downloadPreviewBtn.addEventListener('click', async ()=> {
  await ensureImgsLoaded();
  const tmp = document.createElement('canvas'); tmp.width = canvasW; tmp.height = canvasH;
  const tctx = tmp.getContext('2d'); tctx.fillStyle = bgColorEl.value || '#0f0f10'; tctx.fillRect(0,0,canvasW,canvasH);
  if (bgImageObj) drawCoverImage(tctx, bgImageObj, 0,0,canvasW,canvasH);
  await drawLayersToContext(tctx, {});
  tmp.toBlob(blob => { const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = (namePrefixEl.value || 'preview') + ` ${canvasW}x${canvasH}.png`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); }, 'image/png');
});
generateAllBtn.addEventListener('click', ()=> generateAndDownloadAll());

batchModeEl.addEventListener('change', ()=> { comboInfoEl.textContent = ''; });
paddingPxEl.addEventListener('input', ()=> { paddingPx = Number(paddingPxEl.value) || 30; });

/* when template token clicked, allow caret placement */
filenameTemplate.addEventListener('click', (ev)=> {
  if (ev.target.classList && ev.target.classList.contains('token')) placeCaretAfter(ev.target);
});

/* update layer count UI */
function updateLayerCountUI(layerId){
  const L = layers.find(l => l.id === layerId);
  if (!L) return;
  L.items = L.treatAsList ? parseListFromText(L.text || '') : [];
  const pill = document.getElementById('count-' + layerId);
  if (pill) pill.textContent = 'Items: ' + (L.items.length || 0);
}

/* build UI initially */
(function init(){
  canvasW = Number(canvasWEl.value) || 2048; canvasH = Number(canvasHEl.value) || 1152;
  // default two text layers
  layers = [];
  const a = createTextLayerDefault(); a.text = 'Lost?\\nLosing hope?\\nLooking for peace?'; a.treatAsList = true; a.items = parseListFromText(a.text); a.sizePct = 140; a.x = 50; a.y = 20; a.label = 'Headline';
  const b = createTextLayerDefault(); b.text = 'YourSite.org'; b.treatAsList = false; b.sizePct = 36; b.x = 50; b.y = 86; b.label = 'URL';
  layers.push(a, b);
  renderLayersUI();
  // init filename template placeholder
  filenameTemplate.innerHTML = '';
  filenameTemplate.appendChild(document.createTextNode(''));
  refreshDynamicTokenButtons();
})();
</script>
</body>
</html>
