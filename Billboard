<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Batch Text Image Generator</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root { --accent:#1976d2; --token-bg:#1976d2; --token-color:white; --muted:#666; --card-bg:#fff; }
  html,body { height:100%; margin:0; font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; background:#f6f7fb; color:#111; }
  .wrap { display:flex; gap:18px; padding:18px; box-sizing:border-box; height:100%; }
  .left { width:420px; min-width:320px; max-width:480px; overflow:auto; }
  .card { background:var(--card-bg); border:1px solid #e6e8ee; border-radius:10px; padding:12px; margin-bottom:12px; box-shadow:0 1px 0 rgba(0,0,0,0.02); }
  h1 { font-size:18px; margin:0 0 10px 0; }
  label { font-size:13px; color:#333; display:block; margin-bottom:6px; font-weight:600; }
  input[type="text"], input[type="number"], select, textarea { width:100%; padding:8px; border-radius:8px; border:1px solid #d6d8de; box-sizing:border-box; font-size:13px; background:white; }
  textarea { min-height:80px; font-family:monospace; resize:vertical; }
  .small { font-size:12px; color:var(--muted); }
  .row { display:flex; gap:8px; align-items:center; }
  .btn { background:var(--accent); color:white; border:0; padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:700; }
  .btn.secondary { background:#666; }
  .btn.ghost { background:transparent; color:var(--accent); border:1px solid #d6e8ee; font-weight:700; }
  .muted { color:var(--muted); font-size:12px; }
  .layers { display:flex; flex-direction:column; gap:8px; margin-top:8px; }
  .layer-row { border:1px dashed #e0e0e0; padding:8px; border-radius:8px; background:#fbfcff; }
  .layer-header { display:flex; justify-content:space-between; gap:8px; align-items:center; margin-bottom:6px; }
  .layer-title { font-weight:700; font-size:13px; }
  .inline { display:inline-flex; gap:6px; align-items:center; }
  .preview-area { flex:1; display:flex; flex-direction:column; gap:12px; min-width:420px; max-width:100%; }
  #previewCanvas { width:100%; border-radius:8px; border:1px solid #dcdcdc; background:#eee; max-height:70vh; object-fit:contain; }
  .controls { display:flex; gap:8px; flex-wrap:wrap; }
  .token { display:inline-block; padding:4px 8px; border-radius:8px; background:var(--token-bg); color:var(--token-color); font-weight:800; margin:0 4px; font-size:12px; vertical-align:middle; user-select:none; }
  .templateBar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .token-btn { background:#eef5ff; border:1px solid #d6e8ff; padding:6px 8px; border-radius:8px; cursor:pointer; color:var(--accent); font-weight:700; }
  .small-input { width:70px; }
  .file-list { font-size:12px; color:var(--muted); max-height:160px; overflow:auto; padding:4px; background:#fbfbfb; border-radius:6px; border:1px solid #eef2f7; }
  .hint { font-size:12px; color:#666; margin-top:6px; }
  footer { font-size:12px; color:var(--muted); padding:8px 0 20px 0; }
  .token.drop { background:#0b74da; }
  .small-btn { padding:6px 8px; border-radius:8px; border:1px solid #e6e8ee; background:white; cursor:pointer; }
  .two-cols { display:grid; grid-template-columns:1fr 1fr; gap:8px; }
  .reorderBtns { display:flex; gap:6px; }
  .danger { background:#c0392b; }
</style>
</head>
<body>
<div class="wrap">
  <div class="left">
    <div class="card">
      <h1>Batch Text Image Generator</h1>
      <div class="small">Add layers, set relative sizes, paste lists, choose fills, auto-maximize, and export many images fast.</div>
    </div>

    <div class="card">
      <label>Global name (for filenames)</label>
      <input id="namePrefix" placeholder="BrandX" type="text" />

      <label style="margin-top:10px">File name template</label>
      <div class="templateBar">
        <div style="flex:1">
          <div id="filenameTemplate" contenteditable="true" style="min-height:36px; border:1px solid #e6e8ee; padding:6px; border-radius:8px; background:#fff"></div>
        </div>
        <div style="display:flex;flex-direction:column;gap:6px">
          <button class="token-btn" data-token="name" title="Insert name token">name</button>
          <button class="token-btn" data-token="res" title="Insert resolution token">res</button>
        </div>
      </div>
      <div id="dynamicTokenButtons" style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap"></div>
      <div class="hint">Click a token to insert a small colored box. Tokens are replaced when files are generated.</div>
    </div>

    <div class="card">
      <label>Canvas resolution</label>
      <div style="display:flex; gap:8px; align-items:center;">
        <input id="canvasW" class="small-input" type="number" value="2048" /> <span class="muted">px wide</span>
        <input id="canvasH" class="small-input" type="number" value="1152" /> <span class="muted">px high</span>
        <div style="flex:1"></div>
        <button id="applyRes" class="btn ghost">Apply</button>
      </div>

      <label style="margin-top:10px">Background</label>
      <div style="display:flex; gap:8px;">
        <input id="bgColor" type="color" value="#ffffff" />
        <input id="bgImageFile" type="file" accept="image/*" />
        <button id="clearBg" class="btn ghost">Clear</button>
      </div>
      <div class="hint">Background color or image. Image will be scaled to cover the canvas.</div>
    </div>

    <div class="card">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <label>Layers</label>
        <div>
          <button id="addTextLayerBtn" class="btn ghost">Add text layer</button>
          <button id="addImageLayerBtn" class="btn ghost">Add image layer</button>
        </div>
      </div>

      <div class="layers" id="layersContainer"></div>
      <div class="hint">Layers render in order top to bottom. Add many layers, mark some variable for batching.</div>
    </div>

    <div class="card">
      <label>Batch options</label>
      <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
        <select id="batchMode">
          <option value="cartesian">Full combos (cartesian)</option>
          <option value="single">Vary one layer only</option>
        </select>
        <select id="singleLayerSelect"></select>
        <div style="flex:1"></div>
        <input id="paddingPx" type="number" value="30" class="small-input" />
        <span class="muted">padding px</span>
      </div>

      <div style="display:flex; gap:8px;">
        <button id="autoMaxBtn" class="btn">Auto maximize and preview</button>
        <button id="generateAllBtn" class="btn">Generate and download all</button>
        <button id="downloadPreviewBtn" class="btn secondary">Download preview</button>
      </div>

      <div class="hint" id="comboInfo"></div>
      <div id="progress" class="hint"></div>
    </div>

    <footer class="card">
      <div style="display:flex; gap:8px; align-items:center;">
        <div class="muted">Tip</div>
        <div class="small">Use variable mode to paste many options into any text layer. The app will produce combinations and name files using the tokens you put in the file template.</div>
      </div>
    </footer>
  </div>

  <div class="preview-area">
    <div class="card" style="display:flex; flex-direction:column; gap:8px;">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <label>Preview</label>
        <div class="controls">
          <div class="muted" id="resolutionLabel">2048 x 1152</div>
        </div>
      </div>
      <canvas id="previewCanvas" width="2048" height="1152"></canvas>
      <div style="display:flex; gap:8px; justify-content:flex-end;">
        <button id="regenBtn" class="btn ghost">Render current</button>
      </div>
    </div>

    <div class="card">
      <label>Files ready to generate</label>
      <div class="file-list" id="fileList">No files yet. Click Generate and download all to build files.</div>
    </div>
  </div>
</div>

<!-- JSZip CDN used for zipping many images -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

<script>
/* Batch Text Image Generator
   - unlimited layers
   - relative sizes preserved on auto-max
   - tokenized filename template (WYSIWYG tokens)
   - background color / image cover
   - text fills: color or image masked into text
   - variable lists per text layer, cartesian or single-layer-only
   - zip output (JSZip)
*/

/* ---------- utilities ---------- */
const $ = s => document.querySelector(s);
const $$ = s => Array.from(document.querySelectorAll(s));
const uid = (p='l') => p + Math.random().toString(36).slice(2,9);
const clamp = (v,a,b) => Math.max(a, Math.min(b,v));
const readFileAsDataURL = f => new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsDataURL(f); });

/* ---------- state ---------- */
let layers = []; // ordered top-to-bottom
let bgImageData = null;
let bgImageObj = null;
let canvasW = 2048, canvasH = 1152;
let paddingPx = 30;
const previewCanvas = $('#previewCanvas');
const previewCtx = previewCanvas.getContext('2d', { alpha: true });
const measureCanvas = document.createElement('canvas');
const measureCtx = measureCanvas.getContext('2d');
let zipAvailable = typeof JSZip !== 'undefined';

/* default layer factory */
function createTextLayer() {
  return {
    id: uid('t'),
    type: 'text',
    label: 'Text',
    visible: true,
    variable: false,
    text: 'Headline',
    variants: [],
    sizePct: 100,
    lineHeight: 1.05,
    fillType: 'color', // color | image
    color: '#000000',
    fillImageData: null, // data URL
    fillImageObj: null,
    align: 'center', // center, top, bottom, left, right
    x: 50, y: 50,
    maxWidthPct: 90
  };
}
function createImageLayer() {
  return {
    id: uid('i'),
    type: 'image',
    label: 'Image',
    visible: true,
    imageData: null,
    imageObj: null,
    x: 50, y: 50,
    maxWidthPct: 80,
    maxHeightPct: 80,
    fit: 'cover' // cover or contain
  };
}

/* ---------- DOM refs ---------- */
const layersContainer = $('#layersContainer');
const dynamicTokenButtons = $('#dynamicTokenButtons');
const filenameTemplate = $('#filenameTemplate');
const namePrefixEl = $('#namePrefix');
const canvasWEl = $('#canvasW');
const canvasHEl = $('#canvasH');
const applyResBtn = $('#applyRes');
const bgColorEl = $('#bgColor');
const bgImageFileEl = $('#bgImageFile');
const clearBgBtn = $('#clearBg');
const addTextLayerBtn = $('#addTextLayerBtn');
const addImageLayerBtn = $('#addImageLayerBtn');
const batchModeEl = $('#batchMode');
const singleLayerSelect = $('#singleLayerSelect');
const paddingPxEl = $('#paddingPx');
const autoMaxBtn = $('#autoMaxBtn');
const generateAllBtn = $('#generateAllBtn');
const downloadPreviewBtn = $('#downloadPreviewBtn');
const regenBtn = $('#regenBtn');
const fileListEl = $('#fileList');
const comboInfoEl = $('#comboInfo');
const progressEl = $('#progress');
const resolutionLabel = $('#resolutionLabel');

/* ---------- helpers for template tokens ---------- */
function makeTokenSpan(name) {
  const span = document.createElement('span');
  span.className = 'token';
  span.dataset.token = name;
  span.contentEditable = "false";
  span.textContent = name;
  return span;
}
function insertTokenToTemplate(tokenName) {
  const sel = window.getSelection();
  filenameTemplate.focus();
  const span = makeTokenSpan(tokenName);
  if (!sel || sel.rangeCount === 0) {
    filenameTemplate.appendChild(span);
    // add a space after for ease
    filenameTemplate.appendChild(document.createTextNode(' '));
    placeCaretAfter(span);
    return;
  }
  const range = sel.getRangeAt(0);
  range.collapse(false);
  range.insertNode(span);
  range.setStartAfter(span);
  range.setEndAfter(span);
  sel.removeAllRanges();
  sel.addRange(range);
  // insert space
  const sp = document.createTextNode(' ');
  range.insertNode(sp);
  range.setStartAfter(sp);
  range.setEndAfter(sp);
  sel.removeAllRanges();
  sel.addRange(range);
}
function placeCaretAfter(node) {
  const range = document.createRange();
  range.setStartAfter(node);
  range.collapse(true);
  const sel = window.getSelection();
  sel.removeAllRanges();
  sel.addRange(range);
}

/* ---------- UI - layers ---------- */
function refreshDynamicTokenButtons() {
  dynamicTokenButtons.innerHTML = '';
  // create buttons for each text layer
  layers.forEach((L, idx) => {
    if (L.type === 'text') {
      const b = document.createElement('button');
      b.className = 'token-btn';
      b.textContent = 'text' + (idx+1);
      b.dataset.token = 'text' + (idx+1);
      b.title = 'Insert token for text layer ' + (idx+1);
      b.addEventListener('click', () => insertTokenToTemplate(b.dataset.token));
      dynamicTokenButtons.appendChild(b);
    }
  });
  // add an "index" token to help with collisions
  const idxBtn = document.createElement('button');
  idxBtn.className = 'token-btn';
  idxBtn.textContent = 'index';
  idxBtn.dataset.token = 'index';
  idxBtn.title = 'Insert incremental index token';
  idxBtn.addEventListener('click', () => insertTokenToTemplate('index'));
  dynamicTokenButtons.appendChild(idxBtn);
}
function addTextLayer() {
  const L = createTextLayer();
  layers.push(L);
  renderLayersUI();
}
function addImageLayer() {
  const L = createImageLayer();
  layers.push(L);
  renderLayersUI();
}
function moveLayerUp(id) {
  const i = layers.findIndex(x=>x.id===id);
  if (i <= 0) return;
  const a = layers.splice(i,1)[0];
  layers.splice(i-1,0,a);
  renderLayersUI();
}
function moveLayerDown(id) {
  const i = layers.findIndex(x=>x.id===id);
  if (i === -1 || i >= layers.length-1) return;
  const a = layers.splice(i,1)[0];
  layers.splice(i+1,0,a);
  renderLayersUI();
}
function removeLayer(id) {
  layers = layers.filter(x=>x.id!==id);
  renderLayersUI();
}
function renderLayersUI() {
  layersContainer.innerHTML = '';
  layers.forEach((layer, idx) => {
    const el = document.createElement('div');
    el.className = 'layer-row';
    el.dataset.id = layer.id;

    const header = document.createElement('div');
    header.className = 'layer-header';
    const title = document.createElement('div');
    title.className = 'layer-title';
    title.textContent = (idx+1) + '. ' + (layer.label || (layer.type==='text' ? 'Text' : 'Image'));
    header.appendChild(title);

    const headerControls = document.createElement('div');
    headerControls.className = 'inline';
    const up = document.createElement('button'); up.textContent='↑'; up.className='btn ghost'; up.style.padding='4px 8px';
    up.addEventListener('click', ()=> moveLayerUp(layer.id));
    const down = document.createElement('button'); down.textContent='↓'; down.className='btn ghost'; down.style.padding='4px 8px';
    down.addEventListener('click', ()=> moveLayerDown(layer.id));
    const removeBtn = document.createElement('button'); removeBtn.textContent='Remove'; removeBtn.className='btn ghost';
    removeBtn.addEventListener('click', ()=> { if(confirm('Remove layer?')) removeLayer(layer.id); });
    headerControls.append(up, down, removeBtn);
    header.appendChild(headerControls);
    el.appendChild(header);

    // body
    const body = document.createElement('div');
    body.style.display = 'grid';
    body.style.gridTemplateColumns = '1fr';
    body.style.gap = '8px';

    const visRow = document.createElement('div');
    visRow.className = 'row';
    const visC = document.createElement('input'); visC.type='checkbox'; visC.checked = layer.visible;
    visC.addEventListener('change', ()=> { layer.visible = visC.checked; renderPreview(); });
    const visLabel = document.createElement('div'); visLabel.className='small muted'; visLabel.textContent='Visible';
    visRow.append(visC, visLabel);
    body.appendChild(visRow);

    // Common inputs
    const labelLabel = document.createElement('label'); labelLabel.textContent = 'Layer label';
    const labelInput = document.createElement('input'); labelInput.type = 'text'; labelInput.value = layer.label || '';
    labelInput.addEventListener('input', ()=> { layer.label = labelInput.value; renderLayersUI(); });
    body.appendChild(labelLabel); body.appendChild(labelInput);

    if (layer.type === 'text') {
      const modeRow = document.createElement('div'); modeRow.style.display='flex'; modeRow.style.gap='8px'; modeRow.style.alignItems='center';
      const fixedRadio = document.createElement('input'); fixedRadio.type='radio'; fixedRadio.name = 'mode_'+layer.id; fixedRadio.checked = !layer.variable;
      const fixedLabel = document.createElement('div'); fixedLabel.className='small muted'; fixedLabel.textContent='Fixed';
      const varRadio = document.createElement('input'); varRadio.type='radio'; varRadio.name = 'mode_'+layer.id; varRadio.checked = layer.variable;
      const varLabel = document.createElement('div'); varLabel.className='small muted'; varLabel.textContent='Variable (one per line)';
      modeRow.append(fixedRadio, fixedLabel, varRadio, varLabel);
      body.appendChild(modeRow);

      const fixedInput = document.createElement('input'); fixedInput.type='text'; fixedInput.value = layer.text || '';
      const varTextarea = document.createElement('textarea'); varTextarea.placeholder = 'One option per line'; varTextarea.value = (layer.variants||[]).join('\n');
      fixedInput.style.display = layer.variable ? 'none' : 'block';
      varTextarea.style.display = layer.variable ? 'block' : 'none';
      fixedInput.addEventListener('input', ()=> { layer.text = fixedInput.value; renderPreview(); });
      varTextarea.addEventListener('input', ()=> { layer.variants = varTextarea.value.split(/\\r?\\n/).map(s=>s.trim()).filter(Boolean); renderPreview(); });
      fixedRadio.addEventListener('change', ()=> { layer.variable = false; fixedInput.style.display='block'; varTextarea.style.display='none'; });
      varRadio.addEventListener('change', ()=> { layer.variable = true; fixedInput.style.display='none'; varTextarea.style.display='block'; });

      body.appendChild(fixedInput);
      body.appendChild(varTextarea);

      // size and line height
      const twoCols = document.createElement('div'); twoCols.className='two-cols';
      const sizeLabel = document.createElement('label'); sizeLabel.textContent = 'Relative size (%)';
      const sizeInput = document.createElement('input'); sizeInput.type='number'; sizeInput.value = layer.sizePct; sizeInput.min=1;
      sizeInput.addEventListener('input', ()=> { layer.sizePct = Number(sizeInput.value)||100; renderPreview(); });
      const lhLabel = document.createElement('label'); lhLabel.textContent = 'Line height x';
      const lhInput = document.createElement('input'); lhInput.type='number'; lhInput.step='0.05'; lhInput.value = layer.lineHeight || 1.05;
      lhInput.addEventListener('input', ()=> { layer.lineHeight = Number(lhInput.value)||1.05; renderPreview(); });
      twoCols.append(sizeLabel, lhLabel, sizeInput, lhInput);
      body.appendChild(twoCols);

      // fill
      const fillLabel = document.createElement('label'); fillLabel.textContent='Fill';
      const fillSelect = document.createElement('select'); fillSelect.innerHTML = '<option value="color">Color</option><option value="image">Image</option>';
      fillSelect.value = layer.fillType || 'color';
      const colorInput = document.createElement('input'); colorInput.type='color'; colorInput.value = layer.color || '#000000';
      const imgFile = document.createElement('input'); imgFile.type='file'; imgFile.accept='image/*';
      if (layer.fillType === 'image') { colorInput.style.display='none'; } else { imgFile.style.display='none'; }
      fillSelect.addEventListener('change', ()=> {
        layer.fillType = fillSelect.value;
        colorInput.style.display = layer.fillType === 'color' ? 'inline-block' : 'none';
        imgFile.style.display = layer.fillType === 'image' ? 'inline-block' : 'none';
        renderPreview();
      });
      colorInput.addEventListener('input', ()=> { layer.color = colorInput.value; renderPreview(); });
      imgFile.addEventListener('change', async (e)=> {
        const f = e.target.files[0]; if(!f) return;
        layer.fillImageData = await readFileAsDataURL(f);
        layer.fillImageObj = await dataURLToImage(layer.fillImageData);
        renderPreview();
      });

      body.appendChild(fillLabel);
      body.appendChild(fillSelect);
      body.appendChild(colorInput);
      body.appendChild(imgFile);

      // position and max width
      const posRow = document.createElement('div'); posRow.style.display='flex'; posRow.style.gap='6px';
      const alignSel = document.createElement('select'); alignSel.innerHTML = '<option value="center">center</option><option value="top">top</option><option value="bottom">bottom</option><option value="left">left</option><option value="right">right</option>';
      alignSel.value = layer.align || 'center';
      alignSel.addEventListener('change', ()=> { layer.align = alignSel.value; renderPreview(); });

      const xPos = document.createElement('input'); xPos.type='number'; xPos.value = layer.x || 50; xPos.min=0; xPos.max=100; xPos.className='small-input';
      xPos.addEventListener('input', ()=> { layer.x = clamp(Number(xPos.value)||50,0,100); renderPreview(); });
      const yPos = document.createElement('input'); yPos.type='number'; yPos.value = layer.y || 50; yPos.min=0; yPos.max=100; yPos.className='small-input';
      yPos.addEventListener('input', ()=> { layer.y = clamp(Number(yPos.value)||50,0,100); renderPreview(); });
      const maxW = document.createElement('input'); maxW.type='number'; maxW.value = layer.maxWidthPct || 90; maxW.min=1; maxW.max=100; maxW.className='small-input';
      maxW.addEventListener('input', ()=> { layer.maxWidthPct = clamp(Number(maxW.value)||90,1,100); renderPreview(); });

      posRow.append(alignSel, xPos, yPos, maxW);
      body.appendChild(posRow);
    } else if (layer.type === 'image') {
      // image layer inputs
      const fileRow = document.createElement('div'); fileRow.style.display='flex'; fileRow.style.gap='8px'; fileRow.style.alignItems='center';
      const fileInput = document.createElement('input'); fileInput.type='file'; fileInput.accept='image/*';
      const fitSel = document.createElement('select'); fitSel.innerHTML = '<option value="cover">cover</option><option value="contain">contain</option>'; fitSel.value = layer.fit;
      const maxW = document.createElement('input'); maxW.type='number'; maxW.value = layer.maxWidthPct || 80; maxW.min=1; maxW.max=100; maxW.className='small-input';
      const maxH = document.createElement('input'); maxH.type='number'; maxH.value = layer.maxHeightPct || 80; maxH.min=1; maxH.max=100; maxH.className='small-input';
      fileInput.addEventListener('change', async (e)=> { const f = e.target.files[0]; if(!f) return; layer.imageData = await readFileAsDataURL(f); layer.imageObj = await dataURLToImage(layer.imageData); renderPreview(); });
      fitSel.addEventListener('change', ()=> { layer.fit = fitSel.value; renderPreview(); });
      maxW.addEventListener('input', ()=> { layer.maxWidthPct = clamp(Number(maxW.value)||80,1,100); renderPreview(); });
      maxH.addEventListener('input', ()=> { layer.maxHeightPct = clamp(Number(maxH.value)||80,1,100); renderPreview(); });

      fileRow.append(fileInput, fitSel, maxW, maxH);
      body.appendChild(fileRow);

      const posRow = document.createElement('div'); posRow.style.display='flex'; posRow.style.gap='6px';
      const xPos = document.createElement('input'); xPos.type='number'; xPos.value = layer.x || 50; xPos.min=0; xPos.max=100; xPos.className='small-input';
      const yPos = document.createElement('input'); yPos.type='number'; yPos.value = layer.y || 50; yPos.min=0; yPos.max=100; yPos.className='small-input';
      xPos.addEventListener('input', ()=> { layer.x = clamp(Number(xPos.value)||50,0,100); renderPreview(); });
      yPos.addEventListener('input', ()=> { layer.y = clamp(Number(yPos.value)||50,0,100); renderPreview(); });
      posRow.append(xPos, yPos);
      body.appendChild(posRow);
    }

    el.appendChild(body);
    layersContainer.appendChild(el);
  });

  // update singleLayerSelect
  singleLayerSelect.innerHTML = '';
  layers.forEach((L, i) => {
    const o = document.createElement('option'); o.value = L.id; o.textContent = (i+1)+'. '+(L.label||L.type);
    singleLayerSelect.appendChild(o);
  });

  refreshDynamicTokenButtons();
  renderPreview();
}

/* ---------- image helpers ---------- */
function dataURLToImage(dataURL) {
  return new Promise((res, rej) => {
    const img = new Image();
    img.onload = ()=> res(img);
    img.onerror = rej;
    img.src = dataURL;
  });
}

/* ---------- text measurement & wrapping ---------- */
function setMeasureFont(fontSize, fontFamily='sans-serif') {
  measureCtx.font = `${Math.round(fontSize)}px ${fontFamily}`;
  measureCtx.textBaseline = 'middle';
}
function wrapTextLines(ctx, text, maxWidth) {
  // returns array of lines; naive word-wrap
  const words = text.split(/\s+/);
  const lines = [];
  let line = '';
  for (let w of words) {
    const test = line ? (line + ' ' + w) : w;
    const width = ctx.measureText(test).width;
    if (width <= maxWidth || !line) {
      line = test;
    } else {
      lines.push(line);
      line = w;
    }
  }
  if (line) lines.push(line);
  return lines;
}
function measureTextBlock(text, fontSize, lineHeight, maxWidthPx) {
  setMeasureFont(fontSize);
  // multi-line support
  const lines = [];
  // split on explicit lines and wrap each
  const paragraphs = text.split(/\\r?\\n/);
  for (const p of paragraphs) {
    const wrapped = wrapTextLines(measureCtx, p || '', maxWidthPx);
    if (wrapped.length === 0) wrapped.push('');
    wrapped.forEach(l=>lines.push(l));
  }
  const lineH = fontSize * lineHeight;
  let width = 0;
  for (const l of lines) {
    width = Math.max(width, measureCtx.measureText(l).width);
  }
  const height = lines.length * lineH;
  return { width, height, lines, lineHeight: lineH };
}

/* ---------- auto-maximization (binary search) ---------- */
async function autoMaximizeAndPreview() {
  paddingPx = Number(paddingPxEl.value) || 30;
  // choose max base size upper bound heuristically
  let lo = 2;
  let hi = Math.max(canvasW, canvasH) * 2; // conservative
  const maxIter = 20;
  let best = lo;
  // binary search for largest base size that fits all visible text layers
  for (let iter=0; iter<maxIter; iter++) {
    const mid = Math.floor((lo + hi) / 2);
    if (await baseSizeFits(mid)) {
      best = mid;
      lo = mid + 1;
    } else {
      hi = mid - 1;
    }
  }
  // best found
  progressEl.textContent = 'Auto max base size: ' + best + ' px (base).';
  // store chosen base on a pseudo global
  window.__chosenBaseSize = best;
  renderPreview();
}
// returns true if baseSize fits
async function baseSizeFits(baseSize) {
  // for each visible text layer compute its bounding box
  for (const L of layers) {
    if (!L.visible || L.type !== 'text') continue;
    // determine text to use: any variant ok; we must check longest variant to be safe
    const samples = L.variable ? (L.variants && L.variants.length ? L.variants : ['']) : [L.text || ''];
    // include max-length variant
    let longest = samples.reduce((a,b)=> a.length > b.length ? a : b, samples[0] || '');
    // use font size scaled by layer.sizePct
    const fontSize = baseSize * (Number(L.sizePct) || 100) / 100;
    const maxWidthPx = canvasW * ((Number(L.maxWidthPct)||90) / 100);
    const measured = measureTextBlock(longest, fontSize, Number(L.lineHeight)||1.05, maxWidthPx);
    // determine anchor point
    const anchorX = canvasW * (Number(L.x)||50) / 100;
    const anchorY = canvasH * (Number(L.y)||50) / 100;
    // compute extents depending on alignment mapping
    const align = L.align || 'center';
    let left, top;
    if (align === 'center') { left = anchorX - measured.width/2; top = anchorY - measured.height/2; }
    else if (align === 'top') { left = anchorX - measured.width/2; top = anchorY; }
    else if (align === 'bottom') { left = anchorX - measured.width/2; top = anchorY - measured.height; }
    else if (align === 'left') { left = anchorX; top = anchorY - measured.height/2; }
    else if (align === 'right') { left = anchorX - measured.width; top = anchorY - measured.height/2; }
    else { left = anchorX - measured.width/2; top = anchorY - measured.height/2; }

    // check padding bounds
    if (left < paddingPx - 0.5) return false;
    if (top < paddingPx - 0.5) return false;
    if (left + measured.width > canvasW - paddingPx + 0.5) return false;
    if (top + measured.height > canvasH - paddingPx + 0.5) return false;
  }
  return true;
}

/* ---------- rendering ---------- */
function clearCanvas(ctx) {
  ctx.clearRect(0,0, canvasW, canvasH);
}
async function renderPreview(specificParams = null) {
  // specificParams can supply per-layer override of text/image for live preview combos; optional
  previewCanvas.width = canvasW;
  previewCanvas.height = canvasH;
  resolutionLabel.textContent = canvasW + ' x ' + canvasH;
  clearCanvas(previewCtx);
  // background
  previewCtx.fillStyle = bgColorEl.value || '#ffffff';
  previewCtx.fillRect(0,0,canvasW, canvasH);
  if (bgImageObj) {
    drawCoverImage(previewCtx, bgImageObj, 0,0,canvasW,canvasH);
  }
  // base size: either computed or fallback
  let baseSize = window.__chosenBaseSize || Math.round(Math.min(canvasW, canvasH)/6);
  // iterate layers in order
  for (const L of layers) {
    if (!L.visible) continue;
    if (L.type === 'image') {
      if (!L.imageObj) continue;
      // compute draw size
      const maxWpx = canvasW * (L.maxWidthPct / 100);
      const maxHpx = canvasH * (L.maxHeightPct / 100);
      let dw = L.imageObj.width, dh = L.imageObj.height;
      if (L.fit === 'cover') {
        const scale = Math.max(maxWpx / dw, maxHpx / dh);
        dw *= scale; dh *= scale;
      } else {
        const scale = Math.min(maxWpx / dw, maxHpx / dh);
        dw *= scale; dh *= scale;
      }
      const cx = canvasW * (L.x / 100);
      const cy = canvasH * (L.y / 100);
      const dx = Math.round(cx - dw/2);
      const dy = Math.round(cy - dh/2);
      previewCtx.drawImage(L.imageObj, dx, dy, dw, dh);
    } else if (L.type === 'text') {
      const text = specificParams && specificParams[L.id] !== undefined ? specificParams[L.id] : (L.variable ? (L.variants && L.variants.length ? L.variants[0] : '') : (L.text || ''));
      const fontSize = baseSize * (Number(L.sizePct)||100)/100;
      const lineHeight = Number(L.lineHeight) || 1.05;
      const maxWidthPx = canvasW * ((Number(L.maxWidthPct)||90) / 100);
      // measure and split lines
      setMeasureFont(fontSize);
      const block = measureTextBlock(text, fontSize, lineHeight, maxWidthPx);
      // prepare text drawing styles
      const align = L.align || 'center';
      let textAlign = 'center';
      let baseline = 'middle';
      if (align === 'center') { textAlign='center'; baseline='middle'; }
      else if (align === 'top') { textAlign='center'; baseline='top'; }
      else if (align === 'bottom') { textAlign='center'; baseline='bottom'; }
      else if (align === 'left') { textAlign='left'; baseline='middle'; }
      else if (align === 'right') { textAlign='right'; baseline='middle'; }

      previewCtx.save();
      previewCtx.font = `${Math.round(fontSize)}px sans-serif`;
      previewCtx.textAlign = textAlign;
      previewCtx.textBaseline = baseline;
      previewCtx.lineWidth = 1;

      const anchorX = canvasW * (Number(L.x)||50) / 100;
      const anchorY = canvasH * (Number(L.y)||50) / 100;
      // compute starting y depending on baseline mapping and block height
      let startY;
      if (baseline === 'middle') startY = anchorY - block.height/2 + (block.lineHeight/2);
      else if (baseline === 'top') startY = anchorY;
      else if (baseline === 'bottom') startY = anchorY - block.height + (block.lineHeight/2);
      else startY = anchorY - block.height/2 + (block.lineHeight/2);

      // drawing color fill
      if (L.fillType === 'color' || !L.fillImageObj) {
        previewCtx.fillStyle = L.color || '#000000';
        for (let i=0;i<block.lines.length;i++) {
          const line = block.lines[i];
          const y = startY + i * block.lineHeight;
          previewCtx.fillText(line, anchorX, y);
        }
      } else {
        // image-as-fill: draw image into temp canvas then mask with text using destination-in
        const tmp = document.createElement('canvas');
        tmp.width = canvasW;
        tmp.height = canvasH;
        const tctx = tmp.getContext('2d');
        // draw image to cover area or align with layer bounding box
        // we'll draw full-canvas cover of the text bounding box to preserve scale
        // compute text bounding box position
        let left;
        if (textAlign === 'center') left = anchorX - block.width/2;
        else if (textAlign === 'left') left = anchorX;
        else left = anchorX - block.width;
        const top = startY - (block.lineHeight/2);

        // draw fill image so that it covers the text box
        const img = L.fillImageObj;
        if (img) {
          // compute scale to cover text box
          let sx = block.width > 0 ? block.width : 10;
          let sy = block.height > 0 ? block.height : 10;
          let scale = Math.max(sx / img.width, sy / img.height);
          const dw = img.width * scale;
          const dh = img.height * scale;
          const dx = left + (block.width - dw)/2;
          const dy = top + (block.height - dh)/2;
          tctx.drawImage(img, dx, dy, dw, dh);
        }
        // set composite to destination-in so text defines alpha
        tctx.globalCompositeOperation = 'destination-in';
        tctx.fillStyle = 'black';
        tctx.font = previewCtx.font;
        tctx.textAlign = previewCtx.textAlign;
        tctx.textBaseline = previewCtx.textBaseline;
        for (let i=0;i<block.lines.length;i++) {
          const line = block.lines[i];
          const y = startY + i * block.lineHeight;
          tctx.fillText(line, anchorX, y);
        }
        // now composite tmp onto preview
        previewCtx.drawImage(tmp, 0, 0);
      }
      previewCtx.restore();
    }
  }
}

/* ---------- draw helper ---------- */
function drawCoverImage(ctx, img, x,y,w,h) {
  // draws image cover style (like background-size: cover)
  const iw = img.width, ih = img.height;
  const scale = Math.max(w/iw, h/ih);
  const dw = iw * scale, dh = ih * scale;
  const dx = x + (w - dw)/2;
  const dy = y + (h - dh)/2;
  ctx.drawImage(img, dx, dy, dw, dh);
}

/* ---------- generating combos and files ---------- */
function gatherVariableLists() {
  // returns matrix of arrays per variable text layer (in order of layers)
  const vars = [];
  layers.forEach(L => {
    if (L.type === 'text' && L.variable) {
      vars.push({layer: L, values: L.variants && L.variants.length ? L.variants.slice() : ['']});
    }
  });
  return vars;
}
function countCombinations() {
  const vars = gatherVariableLists();
  if (batchModeEl.value === 'single') {
    // single variable selection
    const selId = singleLayerSelect.value;
    const s = vars.find(v => v.layer.id === selId);
    return s ? s.values.length : 0;
  }
  // cartesian
  if (vars.length === 0) return 0;
  return vars.reduce((acc, v) => acc * Math.max(1, v.values.length), 1);
}
function buildAllCombos() {
  // returns array of maps {layerId: textValue, ...}
  const vars = gatherVariableLists();
  if (vars.length === 0) return []; // nothing variable
  if (batchModeEl.value === 'single') {
    const selId = singleLayerSelect.value;
    const chosenVar = vars.find(v => v.layer.id === selId);
    if (!chosenVar) return [];
    const combos = [];
    for (const val of chosenVar.values) {
      const map = {};
      // for all layers: if this is the chosen layer set val, else set fixed texts
      layers.forEach(L => {
        if (L.type === 'text') {
          if (L.id === chosenVar.layer.id) map[L.id] = val;
          else map[L.id] = L.variable ? (L.variants && L.variants.length ? L.variants[0] : '') : (L.text || '');
        }
      });
      combos.push(map);
    }
    return combos;
  }
  // full cartesian: include all variable layers
  const lists = vars.map(v => ({id: v.layer.id, values: v.values.length ? v.values : ['']}));
  // recursive cartesian product
  const results = [];
  function recurse(i, acc) {
    if (i === lists.length) {
      results.push(Object.assign({}, acc));
      return;
    }
    const cur = lists[i];
    for (const val of cur.values) {
      acc[cur.id] = val;
      recurse(i+1, acc);
    }
  }
  recurse(0, {});
  // ensure all non-variable layers get their fixed text
  return results.map(map => {
    const full = {};
    layers.forEach(L => {
      if (L.type === 'text') {
        full[L.id] = map[L.id] !== undefined ? map[L.id] : (L.variable ? (L.variants && L.variants.length ? L.variants[0] : '') : (L.text || ''));
      }
    });
    return full;
  });
}

/* build filename from template nodes and dataMap
   template contenteditable contains text nodes and spans with class token and data-token attribute
   dataMap provides replacements for tokens like name,res,text1,index
*/
function renderFileNameFromTemplate(dataMap, indexFallback) {
  const nodes = Array.from(filenameTemplate.childNodes);
  let out = '';
  for (const n of nodes) {
    if (n.nodeType === Node.TEXT_NODE) out += n.textContent;
    else if (n.nodeType === Node.ELEMENT_NODE && n.classList.contains('token')) {
      const tk = n.dataset.token;
      if (tk === 'res') out += (canvasW + 'x' + canvasH);
      else if (tk === 'name') out += (namePrefixEl.value || '');
      else if (tk === 'index') out += (indexFallback !== undefined ? String(indexFallback) : '');
      else if (tk.startsWith('text')) {
        // token like text1 -> need to map to actual text by layer index
        // support both "textN" where N is 1-based index in current layers order
        const idx = Number(tk.replace('text',''));
        if (!isNaN(idx) && idx >= 1) {
          // find layer index-th text layer in rendering order
          const textLayers = layers.filter(l => l.type === 'text');
          const L = textLayers[idx-1];
          if (L) {
            // find text value for L from dataMap
            const val = dataMap && dataMap[L.id] !== undefined ? dataMap[L.id] : (L.variable ? (L.variants && L.variants[0] || '') : L.text || '');
            out += (val || '');
          }
        } else {
          out += '';
        }
      } else {
        // unknown token -> keep raw attribute
        out += n.textContent;
      }
    }
  }
  // sanitize and trim
  out = out.trim();
  // replace problematic filename chars
  out = out.replace(/[<>:"/\\|?*]+/g, '_');
  if (!out) out = 'output';
  return out;
}

/* generate and download images */
async function generateAndDownloadAll() {
  paddingPx = Number(paddingPxEl.value) || 30;
  const combos = buildAllCombos();
  if (!combos || combos.length === 0) {
    alert('No variable combinations found. Make at least one layer variable with multiple lines, or use single mode.');
    return;
  }
  const total = combos.length;
  comboInfoEl.textContent = `Preparing ${total} files...`;
  // warn if large
  if (total > 500) {
    if (!confirm('You are about to generate ' + total + ' images. This may be slow and use a lot of memory. Continue?')) return;
  }
  // ensure images are ready
  await ensureAllImagesLoaded();

  const useZip = zipAvailable && total > 1;
  const zip = useZip ? new JSZip() : null;
  let count = 0;
  progressEl.textContent = '';
  for (let i=0;i<combos.length;i++) {
    const map = combos[i];
    // render a canvas for this combo
    const tmp = document.createElement('canvas');
    tmp.width = canvasW;
    tmp.height = canvasH;
    const tctx = tmp.getContext('2d', { alpha:true });
    // render background
    tctx.fillStyle = bgColorEl.value || '#ffffff';
    tctx.fillRect(0,0,canvasW,canvasH);
    if (bgImageObj) drawCoverImage(tctx, bgImageObj, 0,0,canvasW,canvasH);
    // render layers using renderPreview logic but for tctx
    // we will reuse renderPreview code path but with a copy; for brevity, call a helper to draw onto tctx
    await drawLayersToContext(tctx, map);
    const blob = await new Promise(res => tmp.toBlob(res, 'image/png'));
    let filename = renderFileNameFromTemplate(map, i+1);
    filename = filename + ' ' + canvasW + 'x' + canvasH + '.png';
    if (useZip) {
      zip.file(filename, blob);
    } else {
      // download direct
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }
    count++;
    progressEl.textContent = `Generated ${count}/${total}`;
    // small yield for UI
    await new Promise(r => setTimeout(r, 20));
  }
  if (useZip) {
    progressEl.textContent = 'Zipping...';
    const content = await zip.generateAsync({type:'blob'}, (meta)=> {
      progressEl.textContent = `Zipping ${Math.round(meta.percent)}%`;
    });
    const url = URL.createObjectURL(content);
    const a = document.createElement('a');
    a.href = url;
    a.download = (namePrefixEl.value || 'batch') + ` ${canvasW}x${canvasH}.zip`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    progressEl.textContent = 'Done.';
  } else {
    progressEl.textContent = `Finished ${count} downloads.`;
  }
}

/* helper that draws layers to a provided 2d context */
async function drawLayersToContext(ctx, dataMap) {
  // ctx assumed to have same size as canvasW x canvasH
  // background already drawn
  let baseSize = window.__chosenBaseSize || Math.round(Math.min(canvasW, canvasH)/6);
  for (const L of layers) {
    if (!L.visible) continue;
    if (L.type === 'image') {
      if (!L.imageObj) continue;
      const maxWpx = canvasW * (L.maxWidthPct / 100);
      const maxHpx = canvasH * (L.maxHeightPct / 100);
      let dw = L.imageObj.width, dh = L.imageObj.height;
      if (L.fit === 'cover') {
        const scale = Math.max(maxWpx / dw, maxHpx / dh);
        dw *= scale; dh *= scale;
      } else {
        const scale = Math.min(maxWpx / dw, maxHpx / dh);
        dw *= scale; dh *= scale;
      }
      const cx = canvasW * (L.x / 100);
      const cy = canvasH * (L.y / 100);
      const dx = Math.round(cx - dw/2);
      const dy = Math.round(cy - dh/2);
      ctx.drawImage(L.imageObj, dx, dy, dw, dh);
    } else if (L.type === 'text') {
      const text = dataMap[L.id] !== undefined ? dataMap[L.id] : (L.variable ? (L.variants && L.variants.length ? L.variants[0] : '') : (L.text || ''));
      const fontSize = baseSize * (Number(L.sizePct)||100)/100;
      const lineHeight = Number(L.lineHeight) || 1.05;
      const maxWidthPx = canvasW * ((Number(L.maxWidthPct)||90) / 100);
      setMeasureFont(fontSize);
      const block = measureTextBlock(text, fontSize, lineHeight, maxWidthPx);
      const align = L.align || 'center';
      let textAlign = 'center';
      let baseline = 'middle';
      if (align === 'center') { textAlign='center'; baseline='middle'; }
      else if (align === 'top') { textAlign='center'; baseline='top'; }
      else if (align === 'bottom') { textAlign='center'; baseline='bottom'; }
      else if (align === 'left') { textAlign='left'; baseline='middle'; }
      else if (align === 'right') { textAlign='right'; baseline='middle'; }
      ctx.save();
      ctx.font = `${Math.round(fontSize)}px sans-serif`;
      ctx.textAlign = textAlign;
      ctx.textBaseline = baseline;
      const anchorX = canvasW * (Number(L.x)||50) / 100;
      const anchorY = canvasH * (Number(L.y)||50) / 100;
      let startY;
      if (baseline === 'middle') startY = anchorY - block.height/2 + (block.lineHeight/2);
      else if (baseline === 'top') startY = anchorY;
      else startY = anchorY - block.height + (block.lineHeight/2);

      if (L.fillType === 'color' || !L.fillImageObj) {
        ctx.fillStyle = L.color || '#000';
        for (let i=0;i<block.lines.length;i++) {
          const line = block.lines[i];
          const y = startY + i * block.lineHeight;
          ctx.fillText(line, anchorX, y);
        }
      } else {
        // image fill: use offscreen mask approach
        const tmp = document.createElement('canvas'); tmp.width = canvasW; tmp.height = canvasH;
        const tctx = tmp.getContext('2d');
        const img = L.fillImageObj;
        if (img) {
          // compute text bounding box left/top
          let left;
          if (textAlign === 'center') left = anchorX - block.width/2;
          else if (textAlign === 'left') left = anchorX;
          else left = anchorX - block.width;
          const top = startY - (block.lineHeight/2);
          let scale = Math.max(block.width / img.width, block.height / img.height);
          const dw = img.width * scale, dh = img.height * scale;
          const dx = left + (block.width - dw)/2, dy = top + (block.height - dh)/2;
          tctx.drawImage(img, dx, dy, dw, dh);
        }
        tctx.globalCompositeOperation = 'destination-in';
        tctx.fillStyle = 'black';
        tctx.font = ctx.font;
        tctx.textAlign = ctx.textAlign;
        tctx.textBaseline = ctx.textBaseline;
        for (let i=0;i<block.lines.length;i++) {
          const line = block.lines[i];
          const y = startY + i * block.lineHeight;
          tctx.fillText(line, anchorX, y);
        }
        ctx.drawImage(tmp, 0, 0);
      }
      ctx.restore();
    }
  }
}

/* ensure all image objects are loaded */
async function ensureAllImagesLoaded() {
  const promises = [];
  if (bgImageData && !bgImageObj) promises.push((async()=> { bgImageObj = await dataURLToImage(bgImageData); })());
  layers.forEach(L => {
    if (L.type === 'text' && L.fillType === 'image' && L.fillImageData && !L.fillImageObj) {
      promises.push((async()=> { L.fillImageObj = await dataURLToImage(L.fillImageData); })());
    }
    if (L.type === 'image' && L.imageData && !L.imageObj) {
      promises.push((async()=> { L.imageObj = await dataURLToImage(L.imageData); })());
    }
  });
  await Promise.all(promises);
}

/* ---------- UI wiring ---------- */
addTextLayerBtn.addEventListener('click', ()=> { addTextLayer(); });
addImageLayerBtn.addEventListener('click', ()=> { addImageLayer(); });

applyResBtn.addEventListener('click', ()=> {
  canvasW = Math.max(16, Number(canvasWEl.value) || canvasW);
  canvasH = Math.max(16, Number(canvasHEl.value) || canvasH);
  resolutionLabel.textContent = canvasW + ' x ' + canvasH;
  renderPreview();
});

bgImageFileEl.addEventListener('change', async (e)=> {
  const f = e.target.files[0];
  if (!f) return;
  bgImageData = await readFileAsDataURL(f);
  bgImageObj = await dataURLToImage(bgImageData);
  renderPreview();
});
clearBgBtn.addEventListener('click', ()=> { bgImageData = null; bgImageObj = null; bgImageFileEl.value = ''; renderPreview(); });

document.querySelectorAll('.token-btn').forEach(b => {
  b.addEventListener('click', ()=> insertTokenToTemplate(b.dataset.token));
});
dynamicTokenButtons.addEventListener('click', ()=> { /* filled dynamically */ });

autoMaxBtn.addEventListener('click', async ()=> {
  progressEl.textContent = 'Computing best size...';
  await autoMaximizeAndPreview();
});
regenBtn.addEventListener('click', ()=> renderPreview());
downloadPreviewBtn.addEventListener('click', async ()=> {
  await ensureAllImagesLoaded();
  // render preview onto new canvas with same logic to ensure quality
  const tmp = document.createElement('canvas'); tmp.width = canvasW; tmp.height = canvasH;
  const tctx = tmp.getContext('2d');
  tctx.fillStyle = bgColorEl.value || '#fff'; tctx.fillRect(0,0,canvasW,canvasH);
  if (bgImageObj) drawCoverImage(tctx, bgImageObj, 0,0,canvasW,canvasH);
  await drawLayersToContext(tctx, {}); // default values
  tmp.toBlob(blob => {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = (namePrefixEl.value || 'preview') + ` ${canvasW}x${canvasH}.png`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }, 'image/png');
});

generateAllBtn.addEventListener('click', ()=> { generateAndDownloadAll(); });

/* make sure template is focusable/clickable - add placeholder */
filenameTemplate.addEventListener('focus', ()=> {
  if (filenameTemplate.textContent.trim() === '') {
    filenameTemplate.innerHTML = '';
  }
});

/* initial setup */
(function init() {
  // defaults
  canvasW = Number(canvasWEl.value) || 2048;
  canvasH = Number(canvasHEl.value) || 1152;
  resolutionLabel.textContent = canvasW + ' x ' + canvasH;
  // add initial two text layers for convenience
  layers = [];
  const L1 = createTextLayer(); L1.text = 'TOP HEADLINE'; L1.sizePct = 120; L1.x = 50; L1.y = 28; layers.push(L1);
  const L2 = createTextLayer(); L2.text = 'Subhead or call to action'; L2.sizePct = 60; L2.x = 50; L2.y = 65; layers.push(L2);
  renderLayersUI();
  // add event to update dynamic token insertions when template inserted text is clicked
  document.addEventListener('click', (ev)=> {
    if (ev.target.classList && ev.target.classList.contains('token')) {
      // allow removing a token if double clicked
      // single click will just place caret after
      placeCaretAfter(ev.target);
    }
  });
  // populate default filename template
  filenameTemplate.innerHTML = '';
  filenameTemplate.appendChild(document.createTextNode(''));
  // add buttons for initial tokens
  refreshDynamicTokenButtons();
})();
</script>
</body>
</html>
